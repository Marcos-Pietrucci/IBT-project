#+TITLE: GALA protocol protobuf specification
#+PROPERTY: header-args :tangle GALA.proto
#+STARTUP: content
* GALA protocol specification in protobuf
  Using *proto2* for compatibility with proto-c, consider switching to proto3
  - consider switching some fields' encoding from =sint= to =int=
    (better for positive values) based on statistic (cow temperature
    will probably be higer than 0), while environment values can
    remain =sint= since the temperature may vary during the year
  #+begin_comment
  - consider moving all ={min, max, val}= fields inside other messages

    After further discussion this point has been considered not
    necessary as it would only make the file less readable since it
    requires a different definition of the tuple ={min, max, val}= for
    each type used and this just create a lot of confusion instead of
    improving the specification
  #+end_comment
  #+begin_comment
  - consider converting =min= and =max= field to a value computed
    inside thingsboard, to reduce message size

    As the point above, after clarifications with the project manager
    this point can be ignored since it since it came from a
    misunderstanding of the fields values
  #+end_comment
  #+begin_comment
  - consider merging =N7= and =N8= into a single packet, distinguished
    by the header
  - consider merging =N9= and =N10= into a single packet,
    distinguished by the header

    It has been decided to stick as much as possible to the previous
    implementation to avoid changing the workflow of the whole system,
    so this point also can be ignored
  #+end_comment
  TODO:
  - define =Network= enumeration's values

** Protobuf version
Specify which protobuf version to use

#+begin_src protobuf
  syntax = "proto2";
#+end_src

** NodeInfos
   - battery voltage
   - firmware version
   - rolling
   These fields are present in every node (except for node N9 "Weather" and N10 "Gateway"

#+begin_src protobuf
  message NodeInfos {
    required uint32 battery_voltage = 1;
    required uint32 fw_version = 2;
    required uint32  packet_rolling_num = 3;
  }
#+end_src

** N1 specific data
   N1 nodes send data about indoor environment:
   - temperature (wet)
   - light
   - humidity
   - temperature (dry)
  
#+begin_src protobuf
  message DataN1 {
    required sint32 indoor_wb_temperature = 1;
    required uint32 indoor_light = 2;
    required uint32 indoor_humidity = 3;
    required sint32 indoor_db_temperature = 4;
  }
  
  message PayloadN1 {
    required NodeInfos int = 1;
    required DataN1 ext = 2;
  }
#+end_src

** N2 specific data
   N2 nodes send data about cows behavior:
   - bma reset counter
   - cow shock count
   - cow temperature
   - cow features
   - [cow features] [4]
   - cow begavior class
   #+begin_comment
     NOTE: consider moving cow temperature in a sub message

     As previously said in the introduction this operation will not be
     done since it just make the specification harder to understand
   #+end_comment

#+begin_src protobuf
  message DataN2 {
    required uint32  bma_reset_counter = 1;
    required uint32  cow_shock_conunt = 2;
    required uint32  cow_temperature_min = 3;
    required uint32  cow_temperature_max = 4;
    required uint32  cow_temperature_ave = 5;
    repeated float  cow_features_set_0_fx = 6 [packed = true]; // zero or more values
    required uint32 behaviour_classes = 7;
  }
  
  message PayloadN2 {
    required NodeInfos int = 1;
    required DataN2 ext = 2;
  }
#+end_src

** N3 specific data
   N3 nodes send data about water usage and temperature
   - drinking water usage and temperature
   - sprinkler water usage

#+begin_src protobuf
  message DataN3 {
    required uint32 drinking_water_volume_cumulated = 1;
    required sint32 drinking_water_temperature = 2;
    required uint32 sprinkler_water_volume_cumulated = 3;
    required sint32 sprinkler_water_temperature = 4;
  }

  message PayloadN3 {
    required NodeInfos int = 1;
    required DataN3 ext = 2;
  }
#+end_src

** N4 specific data
   N4 nodes send different datas regarding litter
   - conductivity
   - temperature
   - volumetric water count

#+begin_src protobuf
  message DataN4 {
    required uint32 litter_conductivity = 1;
    required sint32 litter_temperature = 2;
    required float  litter_vwc = 3;
  }

  message PayloadN4 {
    required NodeInfos int = 1;
    required DataN4 ext = 2;
  }
#+end_src

** N5 specific data
   N5 nodes are used to measure conditions of the environment inside
   the farm such as sound levels and gas particles concentration
   - sound levels (min, max, avg)
   - gas concentration (ammonia, hydrogen sulfide, carbon dioxide and
     metane)

#+begin_src protobuf
  message DataN5 {
    required uint32  sound_level_min = 1;
    required uint32  sound_level_max = 2;
    required uint32  sound_level_avg = 3;
    required uint32 nh3_ppm = 4;
    required uint32 h2s_ppm = 5;
    required uint32 co2_ppm = 6;
    required uint32 ch4_ppm = 7;
  }
    
  message PayloadN5 {
    required NodeInfos int = 1;
    required DataN5 ext = 2;
  }
#+end_src

** N6 specific data
   N6 nodes measure values related to wind:
   - speed
   - direction

#+begin_src protobuf
  message DataN6 {
    required uint32 indoor_wind_speed_min = 1;
    required uint32 indoor_wind_speed_max = 2;
    required uint32 indoor_wind_speed = 3;
    required uint32 indoor_wind_direction= 4;
  }

  message PayloadN6 {
    required NodeInfos int = 1;
    required DataN6 ext = 2;
  }
#+end_src

** N7 specific data
   N7 only sends one field of data:
   - status of a dry contact (open closed)

#+begin_src protobuf
  enum State {
    OPEN   = 0;
    CLOSED = 1;
  }

  message DataN7 {
    required State dry_contact = 1;
  }

  message PayloadN7 {
    required NodeInfos int = 1;
    required DataN7 ext = 2;
  }
#+end_src

** N8 specific data
   As in N7, this message specify the state of a rele with just two
   states: ={OPEN, CLOSED}=
   #+begin_comment
     N8 looks like an N7 packet, there may be the possibility to
     implement both as an unique packet, only distinguished by the
     node type in the header

     As specified in the introduction this will not be done
   #+end_comment

#+begin_src protobuf
  message DataN8 {
    required State rele = 1;
  }

  message PayloadN8 {
    required NodeInfos int = 1;
    required DataN8 ext = 2;
  }
#+end_src

** N9 specific data
   N9 packets are used to represent the gateway status:
   - power supply status
   - network status and overall weather conditions
#+begin_src protobuf
  enum Network {
    PLACEHOLDER = 0;
    // still no definition for Network enum values
  }

  message StatusGateway {
    required uint32 battery_voltage = 1;
    required uint32 battery_current = 2;
    required uint32 solar_voltage = 3;
    required uint32 solar_current = 4;
    required Network network_type = 5;
    required uint32  signal_strength = 6;
    required double latitude = 7;
    required double longitude = 8;
  }

  message DataN9 {
    required sint32 case_temperature = 1;
    required uint32 case_humidity = 2;
    required sint32 outdoor_temperature = 3;
    required uint32 outdoor_humidity = 4;
    required uint32 outdoor_wind_speed_min = 5;
    required uint32 outdoor_wind_speed_max = 6;
    required uint32 outdoor_wind_speed = 7;
    required uint32 outdoor_wind_direction = 8;
    required uint32 outdoor_rainfall = 9;
  }

  message PayloadN9 {
    required StatusGateway int = 1;
    required DataN9 ext = 2;
  } 
#+end_src

** N10 specific data
   N10 node sends additional data about environment
#+begin_src protobuf
  message PayloadN10 {
    required double latitude = 1;
    required double longitude = 2;
    required sint32 case_temperature = 3;
    required uint32 case_humidity = 4;
    repeated uint32  indoor_insects_count_packed = 5;
  }
#+end_src

** Gateway message
   By implementing this message it is possible to create a single
   large message that group up many smaller messages of the previous
   types and allow to send them all at once reducing the traffic data
   generated by packets overhead

   - NOTE: Since the protocol to transmit data to Thingsboard is MQTT,
     the initial idea was to group up a fixed number of messages
     (e.g.: 10 messages of each type) to exploit the whole payload
     available for a single MQTT packet, this was easy to decide by
     simply looking at the packets size of the nodes and the maximum
     MQTT payload size, but since protobuf uses variable length
     representation for all it's data types, the number of messages
     for a single MQTT packet may vary

#+begin_src protobuf
  message BlobMessage {
    repeated PayloadN1  node1_messages  =  1;
    repeated PayloadN2  node2_messages  =  2;
    repeated PayloadN3  node3_messages  =  3;
    repeated PayloadN4  node4_messages  =  4;
    repeated PayloadN5  node5_messages  =  5;
    repeated PayloadN6  node6_messages  =  6;
    repeated PayloadN7  node7_messages  =  7;
    repeated PayloadN8  node8_messages  =  8;
    repeated PayloadN9  node9_messages  =  9;
    repeated PayloadN10 node10_messages = 10;
  }
#+end_src

\documentclass[10pt,a4]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{geometry}
\geometry{top=3cm,left=2cm,right=2cm,bottom=3cm}
\usepackage[scaled]{helvet}
\usepackage[T1]{fontenc}
\usepackage{url}
\renewcommand\familydefault{\sfdefault}


\author{
    E. Poggi\\
    A. Sancho\\
    M. Rogora \\
    F. P. Marcos V.\\
}
\date{\today}
\title{IBT Solution}

\begin{document}
\maketitle
\tableofcontents


\section{Project data}

\begin{itemize}
\item 
  Project supervisor(s): Carlo Brandolese

\item 
Describe in this table the group that is delivering this project:

\begin{center}
\begin{tabular}{lll}
Last and first name & Person code & Email address\\
\hline
  Edoardo Poggi & 10622154 & edoardo.poggi@mail.polimi.it \\
  Amparo Sancho Arellano & 10913648 & amparo.sancho@mail.polimi.it \\
  Matteo Rogora & 10660258 & matteo.rogora@mail.polimi.it\\
  Marcos Vincius Firmino Pietrucci & 10914211 & marcosvinicius.firmino@mail.polimi.it
\end{tabular}
\end{center}

\item
Describe here how development tasks have been subdivided among members
of the group:

\begin{itemize}
\item we ended up to work all 4 together, given the complexity and novelty of all project aspects, this gave the possibility to all group members to deeply understand all chain pieces, node to cloud.
\item the organisation consisted of working days at IBT Solutions in which, upon arrival, we had a meeting with the employee in charge of the product aspect we were going to work on and, afterwards, the four of us worked together throughout the day to continue with the development of the project.
\end{itemize}

\item Links to the project source code; \url{https://github.com/Marcos-Pietrucci/IBT-project}, because working on project code under IP we can't share the IBT product source code.

\end{itemize}


\section{Project description}

Protocol buffers is a data format used – among other contexts – in IoT embedded applications. In such applications messages typically are generated by small, resource constrained nodes (fog) deployed in-field, then are collected by intermediate systems acting as gateways (edge) and forwarding such messages into the cloud (back-end), where they are eventually stored, manipulated, organized and presented by means of application-specific dashboards. It is clear that fog, edge and back-end systems are significantly different in terms of computational power, storage capabilities, available communication bandwidth, operating systems support, and programming languages used to develop applications.
\\
A message traversing all these layers must either be translated at some point in the flow, requiring different parsers, or must be suited to composed and interpreted in the same way at all the levels, minimizing development effort, errors proneness, and testing time. The goal of the project is to port an existing protocol to a suitable protocol buffer implementation in all the three mentioned layers fog, edge and cloud realizing an end-to-end IoT communication system.
The fog node is an RF SoC module (SiliconLabs EFR32BG13) used in field and showing low-power capabilities, while the edge node integrates the same for communication with fog devices and a 4G/LTE cellular module to communicate to the cloud (ThingsBoard platform) using the MQTT protocol. The following figure shows the simplified architecture of the target system.
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{ibt-schema.png}
    \caption{System Diagram}
\end{figure}

AOS course is important to understand and implement the embedded system's routines as both nodes (sending and receiving) are programmed with different tasks that must be scheduled with a RTOS. AOS is also important to understand how the different information is stored in memory, not having a lot of memory in the nodes, this is a critical step to achieve the correct operation of the node.


\subsection{Design and implementation}
The project consisted in implementing the Protocol Buffers (PB) over the existing RF transmission channel. The current implementation of the communication is based on a proprietary binary protocol, \textbf{GALA}, optimized for minimal messages size. Whose structure can be seen in the Figure \ref{fig:gala} and in the Figure \ref{fig:gala_nodes} can be seen two examples of the eight existing nodes types (different kinds of on-field sensors).\\

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{gala-original-structure.png}
    \caption{GALA}
    \label{fig:gala}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.4]{gala-original-structure-nodes.png}
    \caption{GALA Nodes}
    \label{fig:gala_nodes}
\end{figure}

\textbf{Protocol Buffers} \textbf{PB} (\url{https://developers.google.com/protocol-buffers/}) has been developed internally by Google for inter-machine communication in order to have a language-neutral, platform-neutral and extensible mechanism for serializing structured data. To implement Protocol Buffers in the SiLabs MCU we chose a version that generates a C implementation of the encoder/decoder: \textbf{protobuf-c} (\url{https://github.com/protobuf-c/protobuf-c}).\\

To use Protocol Buffer we first needed to port the current protocol in Protocol Buffer. That is achieved by writing in a interface description language, that is a language that describes the structure of the data from the old GALA protocol. After choosing the required fields to port to PB and having chosen the appropriate datatype where an exact correspondent type didn't existed in PB. After that, a program generates source code from that description that allows to serialize or parse a stream of bytes that contains the structured data.
\\
In our implementation, the C source code generated by proto-c has been included in the MCU program to generate the payload to be sent to the gateway via RF communication.
\\
Before moving to the board code implementation we calculated the overhead introduced by PB for each node type and both best and worse data case scenario. We have done that by writing a test program which uses the source code generated by proto-c and reports the number of bytes of the resulting serialized streams. Later this data has been compared with the size of the payload of the previous protocol. This data is reported in the Table \ref{tab:proto2}.
Given the small MCU's memory and Flash we evaluated the overhead, introduced by the presence of the protobuf-c library in the final binary and the existence of dynamic memory allocation in the protobuf-c code, this later requirements  because in small  micro-controllers dynamic memory usage is not recommended even if supported and more generally avoided in all embedded solution.
\begin{table}[ht]
\begin{center}
\begin{tabular}{llllll}
Node Type & Gala\_old & Protobuf\_min & Protobuf\_max & min $\Delta$\% & max $\Delta$\% \\ \hline
N1        & 26        & 30            & 52            & 115     & 200     \\
N2        & 64        & 76            & 91            & 119     & 142     \\
N3        & 28        & 29            & 41            & 104     & 146     \\
N4        & 24        & 32            & 43            & 133     & 179     \\
N5        & 29        & 37            & 38            & 128     & 131     \\
N6        & 28        & 31            & 35            & 111     & 125     \\
N9        & 55        & 52            & 77            & 95      & 140     \\
N10       & 42        & 34            & 44            & 81      & 105     \\ \hline
          &           &               & Average       & 111     & 146    
\end{tabular}
\caption{Proto2}
\label{tab:proto2}
\end{center}
\end{table}

In our implementation we choose not to repack the data in the gateway but to send the protobuf packet via MQTT to the cloud back-end, this way the gateway is completely agnostic with respect to the data and doesn't require any updates in the event of any PB description modification.

We then explored ThingsBoard platform, we discovered that it only supports proto3, so we had to change our descriptor from proto2 to proto3 and re-test to re-evaluate the overhead. It turned out that was better than before (Table \ref{tab:proto3}). After that, a bug was discovered in the message reception parsing on ThingsBoard so we decided to use message container with \texttt{oneof}. Setting a \texttt{oneof} field will automatically clear all other members of the oneof. So if you set several oneof fields, only the last field you set will still have a value. The gateway device receives all packets and redistributes data to respective node device in ThinksBoard.
Once in ThingsBoard, it is necessary to unpack the information received through MQTT and differentiate between telemetry and attributes. In addition, we have generated the necessary code so that depending on the node ID of the receiving packet, a new device is created in ThingsBoard in order to be able to see all the information in a structured and ordered way.\\

\begin{table}[ht]
\begin{center}
\begin{tabular}{llllll}
Node Type & Gala\_old & Protobuf\_min & Protobuf\_max & min $\Delta$\% & max $\Delta$\% \\ \hline
N1        & 26        & 22            & 54            & 85     & 208     \\
N2        & 64        & 66            & 93            & 103     & 145     \\
N3        & 28        & 23            & 43            & 82     & 154     \\
N4        & 24        & 28            & 45            & 117     & 188     \\
N5        & 29        & 25            & 40            & 86     & 138     \\
N6        & 28        & 25            & 37            & 89     & 132     \\
N9        & 55        & 34            & 79            & 62      & 144     \\
N10       & 42        & 32            & 46            & 76      & 110     \\ \hline
          &           &               & Average       & 88     & 152    
\end{tabular}
\caption{Proto3}
\label{tab:proto3}
\end{center}
\end{table}

IBT then decided to postpone the transition to LoRa, so we continued working on the existing boards and the goal was to reprogram it to be able to work with the existing RF protocol, but with a new data serialization with protobuf. As we can see on table \ref{tab:proto3}, PB has considerably higher overhead when all bits of the payload content are set to one, but, considering that this scenario is extremely unlikely, PB3 has a better performance (compared to GALA) when an average number of bits are set.

There is also a big gain on the cloud side since PB parsing is a built-in feature of ThingsBoard, thus eliminating the necessity of any other middle-ware for GALA to JSON translation.\\

Therefore, in order to continue with the old board, it was necessary to reprogram the nodes and gateway  understanding the current system software. The program consists of a series of tasks scheduled with RTOS (all this part of the code is strictly confidential so we can't attach any example).

The working of the sensing node consists in a network task that periodically sends data to the gateway at predefined intervals and a continuous measure task that with an higher frequency with respect to the network task samples sensor values. The continuous measure task samples data from the sensors and calculates an average, which gets stored in a static structure, accessible to both tasks atomically. Before the sending time, the network task schedules an event for the measuring task in advance. That is done in order to calculate the before mentioned averaging and publishing it on the common structure. After sending the protobuf encoded payload the sending node waits for a small time for an acknowledgement by the gateway.

On the receiving node the only task running is the network one. It continuously waits for packets and send an acknowledgement message to the transmitting peer.

One of the problems encountered during the integration of protobuf was the dynamically allocated memory needed by the library to decode messages on the gateway. Even if the main goal is to have an agnostic gateway we choose to investigate this possibility to understand if it was possible to extract payload data to be used on the gateway in future developments of the product.
To improve the stability of the system we decided to avoid the system's default memory allocator, specifying instead a custom allocator to the protobuf library; This can be done by simply defining a \texttt{ProtobufCAllocator} struct, containing pointers to the custom version of the \texttt{malloc} and \texttt{free} functions, as well as an additional pointer for data related to the allocator.
At first the choice was to use memory pools for allocation, but after carefully reading the protobuf-c library and verifying some assumptions made on the memory allocation and deallocation cycles, we managed to implement the allocator as a really simple stack, to minimize the memory and computation overhead.\\
This implementation takes advantage of two facts:

\begin{itemize}
\item
A task never decodes more than one message at a time
\item 
The decoding process follows a pre-order traversal visits of the tree structure of the message
\end{itemize}
So we know a message is deallocated only once all its submessages has already been deallocated (exception made for a couple of local variables temporarly kept in memory).\\
The whole \texttt{free} process is then reduced to an invalidation of the whole stack dedicated to the message allocation, by resetting its size once the message is not needed anymore.

\section{Project outcomes}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.35]{FinalScheme.png}
    \caption{Outline of performed tasks}
    \label{fig:final}
\end{figure}


\subsection{Concrete outcomes}


At the end of the project we ended up with the  structure of Figure \ref{fig:final} implemented end to end.



\subsection{Learning outcomes}

As we developed the project synchronously, all the members of the group had acquired more or less the same knowledge over the most important topics:

\begin{itemize}

\item
We can emphasize some brand-new areas for all of us on protobuf protocol, thingsboard platform and Simplicity Studio IDE, used for programming the EFR32BG13 micro-controller. The programming was in an embedded C language environment, so we had to be extra careful about memory consumption, a field in which we learned a lot.

\item
Being fully aware of the context differences between a general purpose operating system and an embedded RTOS, interacting with multiple sensors sometimes even on different boards, was crucial for the correct development of the overall system.

\end{itemize}

Apart from those areas, each one of us learned, particularly:

\begin{itemize}
    \item Marcos: protobuf and MQTT protocols. Also learned about RTOS and its environment.
    \item Edoardo: embedded programming especially memory allocation and task synchronization.
    \item Amparo: protobuf protocol, embedded programming and the real challenges and constraints of dealing with a real project.
    \item Matteo: working of the protobuf protocol, task communication and basic memory management inside an RTOS
\end{itemize}


\subsection{Existing knowledge}

As we are not all originally from this university, two of us are international students, our backgrounds are different, which has helped us to enrich each other. First of all, two of members who are originally from Politecnico (Edoardo and Matteo) were able to learn from ES, Sensor systems and Microcontrolli (BA). On the other hand, for the student from Spain (Amparo), the courses taken at Smart ETSII, microprocessor systems and digital electronics, have been useful. Finally, the Brazilian student (Marcos) has experience with several micro-controllers via previous disciplines, but specially because of extracurricular activities (e. g. robotics competitions) and internship as hardware engineer.

We were satisfied on how the project developed, and found our previous knowledge sufficient for allowing us to go further. We had researched a lot about protobuf, a relatively new technology and the learning curve to program Silicon-labs micro-controllers was smooth and achievable.

\subsection{Problems encountered}

As the project is integrated within a real company we encountered some challenges:

\begin{itemize}
\item RTOS task stack full after implementation of protobuf parsing, needed to expand stack size. 
\item Tasks synchronization, ask to publish sensor data while read by another scheduled job.
 \item Need to implement a static allocator to replace use of \texttt{malloc} and use the \texttt{.DATA} section instead of heap.
\end{itemize}

\section{Honor Pledge}

I/We pledge that this work was fully and wholly completed within the criteria
established for academic integrity by Politecnico di Milano (Code of Ethics and
Conduct) and represents my/our original production, unless otherwise cited.
\\
I/We also understand that this project, if successfully graded,  will fulfill part B requirement of the
Advanced Operating System course and that it will be considered valid up until
the AOS exam of Sept. 2023. 

\begin{flushright}
E. Poggi\\
A. Sancho\\
M. Rogora \\
F. P. Marcos V.\\
\end{flushright}


\end{document}
